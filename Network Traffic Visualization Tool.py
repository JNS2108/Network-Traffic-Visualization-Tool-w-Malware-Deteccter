import tkinter as tk
from tkinter import filedialog, ttk, Toplevel
from scapy.all import *
from datetime import datetime
import requests
import openai
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pathlib

API_KEY = 'ADD UR OWN KEY'  # AbuseIPDB key
ABUSEIPDB_URL = 'https://api.abuseipdb.com/api/v2/check' #AbuseIPDB URL
openai.api_key = "ADD UR OWN KEY'" #chat-gpt api key

packet_list = [] #global list for all functions to accept all network packets
filtered_packet = [] # global list to store filtered packets, functions will update from this list
IPDB_info = {} # global dictionary containing quried information on ip addresses from IPDB
current_packet =[] # global list to store current selection of IP that is displayed

def open_file():
    global packet_list, IPDB_info
    file_path = filedialog.askopenfilename(title="Select a PCAP file", filetypes=[("PCAP Files", "*.pcapng"), ("PCAPNG Files", "*.pcap"), ("All Files", "*.*")])
    if file_path:  # Check if a file was selected
        file_extension = pathlib.Path(file_path).suffix
        if file_extension not in (".pcap", ".pcapng"):
            tk.messagebox.showerror("Invalid File Type", "Please select a valid PCAP or PCAPNG file.")
            return
        
        # Proceed with processing the valid PCAP file
        print(f"Selected file: {file_path}")
        packet_list.clear()
        decode_pcap_file(file_path)
        display_packet(packet_list)
        display_protocol_graph(packet_list)
        display_malicious_graph(packet_list)

def decode_pcap_file(pcap_file):
    global packet_list,IPDB_info
    try:
        packets = rdpcap(pcap_file)  # Read packets from the PCAP file
    except Exception as e:
        tk.messagebox.showerror("File Error", f"Failed to read PCAP file: {e}")

    for packet in packets:
        packet_info = {
            "time": datetime.fromtimestamp(float(packet.time)).replace(microsecond=0),
            "src": packet[IP].src if IP in packet else "N/A",
            "dst": packet[IP].dst if IP in packet else "N/A",
            "protocol_id": packet[IP].proto if IP in packet else "N/A",
            "protocol_name": protocol_name(packet),
            "length": len(packet),
            "src_port": packet[TCP].sport if TCP in packet else (packet[UDP].sport if UDP in packet else None),
            "dst_port": packet[TCP].dport if TCP in packet else (packet[UDP].dport if UDP in packet else None),
        }
        packet_list.append(packet_info)
        if packet_info["src"] not in IPDB_info:
            query_ipdb(packet_info["src"])
            print(f"Prompting AbuseIPDB for ip address:{packet_info["src"]}")
        if packet_info["dst"] not in IPDB_info:
            query_ipdb(packet_info["dst"])
            print(f"Prompting AbuseIPDB for ip address:{packet_info["dst"]}")

def protocol_name(packet):
    if ARP in packet:
        return "ARP"
    elif DNS in packet:
        return "DNS"
    elif TCP in packet:
        return "TCP"
    elif UDP in packet:
        return "UDP"
    elif ICMP in packet:
        return "ICMP"
    elif IGMP in packet:
        return "IGMP"
    elif IP in packet:
        return "IP"
    elif RARP in packet:
        return "RARP"
    else:
        return "Other"

def display_packet(packet_list):
    for item in tree.get_children():
        tree.delete(item)

    tree.tag_configure("safe", background="lightgreen")
    tree.tag_configure("unsafe", background="salmon")

    for row in packet_list:
        source_data = IPDB_info.get(row["src"])
        destination_data = IPDB_info.get(row["dst"])

        if source_data["data"]["abuseConfidenceScore"] >= 50 or destination_data["data"]["abuseConfidenceScore"] >= 50:
            row_tag = "unsafe"
        else:
            row_tag = "safe"
        
        tree.insert("", "end", values=(row["time"], row["src"], row["dst"],
                    row["protocol_id"], row["protocol_name"], row["length"],
                    row["src_port"], row["dst_port"]), tags=(row_tag,))

def display_protocol_graph(packets):
    protocol_canvas.delete("all")

    protocol_counts = {}
    for packet in packets:
        protocol = packet['protocol_name']
        if protocol in protocol_counts:
            protocol_counts[protocol] += 1
        else:
            protocol_counts[protocol] = 1
    plt.figure(figsize=(6, 6))
    plt.pie(protocol_counts.values(), labels=protocol_counts.keys(), autopct='%1.1f%%', startangle=90)
    plt.axis('equal')  # Equal aspect ratio ensures pie is drawn as a circle.
    plt.title("Protocol Distribution")

    for widget in protocol_canvas.winfo_children():
        widget.destroy()
    # Embed the pie chart into the Tkinter window
    canvas = FigureCanvasTkAgg(plt.gcf(), master=protocol_canvas)
    canvas.draw()
    canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

def display_malicious_graph(packets):

    safe_ip = 0
    unsafe_ip = 0

    # Count safe and unsafe IPs based on the abuseConfidenceScore
    for packet in packets:
        if ( #checking if IPDB_info["ip"]["data"]["abuseConfidenceScore"] is bigger than 50
            IPDB_info[packet["src"]]["data"]["abuseConfidenceScore"] >= 50 or 
            IPDB_info[packet["dst"]]["data"]["abuseConfidenceScore"] >= 50
        ):
            unsafe_ip += 1
        else:
            safe_ip += 1

    categories = ['Safe IPs', 'Unsafe IPs']
    counts = [safe_ip, unsafe_ip]
    plt.figure(figsize=(4, 3))
    plt.bar(categories, counts, width=0.4, color=['lightgreen', 'salmon'])
    plt.xlabel('IP Status')
    plt.ylabel('Count')
    plt.title('Distribution of Safe vs Unsafe IPs')

    # Clear previous canvas if exists
    for widget in malicious_canvas.winfo_children():
        widget.destroy()

    # Embed the pie chart into the Tkinter window
    canvas = FigureCanvasTkAgg(plt.gcf(), master=malicious_canvas)
    canvas.draw()
    canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

def apply_filter():
    global filtered_packet
    filtered_packet.clear()
    
    # Get filter criteria
    src_ip = src_ip_entry.get()
    dst_ip = dst_ip_entry.get()
    protocol = protocol_combobox.get()
    src_port = src_port_entry.get()
    dst_port = dst_port_entry.get()

    for packet in packet_list:
        if (
            (not src_ip or packet["src"] == src_ip) and
            (not dst_ip or packet["dst"] == dst_ip) and
            (protocol == "All" or (not protocol or packet["protocol_name"] == protocol)) and
            (not src_port or (packet["src_port"] is not None and str(packet["src_port"]) == src_port)) and
            (not dst_port or (packet["dst_port"] is not None and str(packet["dst_port"]) == dst_port))
            ):
                filtered_packet.append(packet)
    display_packet(filtered_packet)
    display_protocol_graph(filtered_packet)
    display_malicious_graph(filtered_packet)
    print("Applied Filters!")

def reset_filter():
    # Clear filter inputs
    src_ip_entry.delete(0, tk.END)
    dst_ip_entry.delete(0, tk.END)
    protocol_combobox.set('All')
    src_port_entry.delete(0, tk.END)
    dst_port_entry.delete(0, tk.END)

    # Display all packets
    display_packet(packet_list)
    display_protocol_graph(packet_list)
    display_malicious_graph(packet_list)
    
    print("Reset Filters!")

def display_ipdb(event):
    selected_item = tree.selection()
    if selected_item:
        item_data = tree.item(selected_item)
        packet_data = item_data['values']

        selected_packet = {
            "Time": packet_data[0],
            "Source IP": packet_data[1],
            "Destination IP": packet_data[2],
            "Protocol ID": packet_data[3],
            "Protocol Name": packet_data[4],
            "Length": packet_data[5],
            "Source Port": packet_data[6],
            "Destination Port": packet_data[7]
        }

        src_details = ""
        dst_details = ""

        for key, value in IPDB_info[selected_packet["Source IP"]]["data"].items():
            src_details += f"{key}: {value}\n"
        for key, value in IPDB_info[selected_packet["Destination IP"]]["data"].items():
            dst_details += f"{key}: {value}\n"

        global current_packet 
        current_packet = ""
        current_packet = "source ip details:\n" + src_details + "destination ip details:\n" + dst_details
        print("New Selection")

    # Insert the source and destination details into the Text widget
    details_text.config(state=tk.NORMAL)    # Enable editing before inserting text
    details_text.delete(1.0, tk.END)  # Clear the Text widget
    details_text.insert(tk.END, "Source IP Details:\n" + src_details + "\n")
    details_text.insert(tk.END, "Destination IP Details:\n" + dst_details + "\n")
    details_text.config(state=tk.DISABLED)

def query_ipdb(ip):
    headers = { 
        'Key': API_KEY, 
        'Accept': 'application/json' 
    } 
    params = { 
        'ipAddress': ip, 
        'maxAgeInDays': 90  
    } 
    try: 
        response = requests.get(ABUSEIPDB_URL, headers=headers, params=params) 
        if response.status_code == 200: 
            IPDB_info[ip] = response.json()
            
        return None 
    except Exception as e: 
        print(f"Error querying malware database: {e}") 
        return None

def query_chatgpt():
    """Query GPT-4 with packet details and return its response."""
    try:
        print("Prompting ChatGPT-4")
        prompt = f"Analyze this network packet data and summarize it for me, in a user friendly way that that is beginner friendly: {current_packet}"
        response = openai.ChatCompletion.create(
            model="gpt-4",  # or "gpt-3.5-turbo"
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        # Extract the content of the response
        message = response['choices'][0]['message']['content']
        print("Recieved Response!")
        return message
    except Exception as e:
        print(f"Error querying GPT-4: {e}")
        return None

def display_chatgpt():
    chatgpt4_text.config(state=tk.NORMAL)  # Enable editing before inserting text
    chatgpt4_text.delete(1.0, tk.END) # Clear exisiting text
    message = query_chatgpt() 
    if message:
        chatgpt4_text.insert(tk.END, message)
    else:
        chatgpt4_text.insert(tk.END, "Error: Unable to get GPT-4 response.")
    chatgpt4_text.config(state=tk.DISABLED)

root = tk.Tk()
root.title("INF1001 Network Packet Analysis Tool")
root.geometry("1700x800")
root.minsize(1700, 800)

# Details window (on the right side)
details_window = tk.Frame(root, width=300, background="lightgreen")
details_window.pack_propagate(0)  # Prevents auto-resizing of the frame
details_window.pack(side="right", fill="y")

information_label = tk.Label(details_window, text="Information View:", font=("Arial", 12, "bold"))
information_label.pack_propagate(0)
information_label.pack(side=tk.TOP, anchor="nw", padx=5, pady=5)

abuseipdb_details = tk.Frame(details_window,width=300,height=300,background="blue")
abuseipdb_details.pack_propagate(0)
abuseipdb_details.pack(side="top",padx=5, pady=5, fill="both")

abuseipdb_scrollbar = ttk.Scrollbar(abuseipdb_details)
abuseipdb_scrollbar.pack(side="right", fill="y")

details_text = tk.Text(abuseipdb_details, yscrollcommand=abuseipdb_scrollbar.set, wrap="word", bg="white")
details_text.pack(side="left", fill="both", expand=True)

abuseipdb_scrollbar.config(command=details_text.yview)
details_text.config(state=tk.DISABLED)

openai_label = tk.Label(details_window, text="ChatGPT-4 Analysis:", font=("Arial", 12, "bold"))
openai_label.pack_propagate(0)
openai_label.pack(side=tk.TOP, anchor="nw", padx=5, pady=5)

prompt_button = ttk.Button(details_window, text="ChatGPT Prompt",command=display_chatgpt)
prompt_button.pack(side=tk.TOP, anchor="nw", padx=5, pady=5)

chatgpt4_details = tk.Frame(details_window,width=300,height=400,background="black")
chatgpt4_details.pack_propagate(0)
chatgpt4_details.pack(side="top",padx=5, pady=5, fill="both")

chatgpt4_scrollbar = ttk.Scrollbar(chatgpt4_details)
chatgpt4_scrollbar.pack(side="right", fill="y")

chatgpt4_text = tk.Text(chatgpt4_details, yscrollcommand=chatgpt4_scrollbar.set, wrap="word", bg="white")
chatgpt4_text.pack(side="left", fill="both", expand=True)

chatgpt4_scrollbar.config(command=details_text.yview)
chatgpt4_text.config(state=tk.DISABLED)

# Left-side frame for both graph and main content
left_frame = tk.Frame(root)
left_frame.pack(side="left", fill="both", expand=True)

# Graph window (at the top left)
graph_window = tk.Frame(left_frame, height=400, background="lightblue")
graph_window.pack_propagate(0)
graph_window.pack(side="top", fill="x")

# Main window (below the graph window)
input_window = tk.Frame(left_frame, height =50, background="lightyellow")
input_window.pack(side="top", fill="x")

# Main window (below the input window)
main_window = tk.Frame(left_frame, height = 400, background="red")
main_window.pack(side="top", fill="both", expand=True)

#graph canvas inside graph window
protocol_canvas = tk.Canvas(graph_window, bg="purple", width=400, height=250)
protocol_canvas.pack(side="left",fill="both",expand=True)

malicious_canvas = tk.Canvas(graph_window, bg="black", width=400, height=250)
malicious_canvas.pack(side="left",fill="both",expand=True)

#open pcap file button
load_button = ttk.Button(input_window, text="Load PCAP File",command=open_file)
load_button.grid(row=0, column=0, padx=5, pady=5)

tk.Label(input_window, text="Source IP:").grid(row=0, column=1, padx=5, pady=5)
src_ip_entry = tk.Entry(input_window)
src_ip_entry.grid(row=0, column=2, padx=5, pady=5)

tk.Label(input_window, text="Destination IP:").grid(row=0, column=3, padx=5, pady=5)
dst_ip_entry = tk.Entry(input_window)
dst_ip_entry.grid(row=0, column=4, padx=5, pady=5)

tk.Label(input_window, text="Protocol:").grid(row=0, column=5, padx=5, pady=5)
protocol_combobox = ttk.Combobox(input_window, values=["All", "TCP", "UDP", "ICMP", "DNS", "ARP"])
protocol_combobox.current(0)
protocol_combobox.grid(row=0, column=6, padx=5, pady=5)

tk.Label(input_window, text="Source Port:").grid(row=0, column=7, padx=5, pady=5)
src_port_entry = tk.Entry(input_window)
src_port_entry.grid(row=0, column=8, padx=5, pady=5)

tk.Label(input_window, text="Destination Port:").grid(row=0, column=9, padx=5, pady=5)
dst_port_entry = tk.Entry(input_window)
dst_port_entry.grid(row=0, column=10, padx=5, pady=5)

filter_button = ttk.Button(input_window, text="Apply Filter",command=apply_filter)
filter_button.grid(row=0, column=11, padx=5, pady=5)

reset_button = ttk.Button(input_window, text="Reset Filter",command=reset_filter)
reset_button.grid(row=0, column=12, padx=5, pady=5)

# Create a Treeview to display packets
columns = ("Time", "Source IP", "Destination IP", "Protocol ID", "Protocol Name", "Length", "Source Port", "Destination Port")
tree = ttk.Treeview(main_window, columns=columns, show="headings", height=15)
tree.pack(fill=tk.BOTH, expand=True)
tree.bind("<Double-1>", display_ipdb)

# Set column headings and widths
header_widths = [80, 80, 80, 50, 80, 10, 60, 60]  # Define widths for each column

for col, width in zip(columns, header_widths):
    tree.heading(col, text=col)
    tree.column(col, width=width)  # Set the width for each column

root.mainloop()

def on_closing():
    print("Closing the application...")
    plt.close('all')
    root.destroy()

root.protocol("WM_DELETE_WINDOW", on_closing)